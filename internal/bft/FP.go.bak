package bft

import (
	"Chamael/internal/party"
	"Chamael/pkg/core"
	"Chamael/pkg/protobuf"
	"Chamael/pkg/utils"
	"context"
	"fmt"
	"time"
)

func MainProcess(p *party.HonestParty, epoch int, itx_inputChannel chan []string, ctx_inputChannel chan []string, outputChannel chan []string) {

	//时期开始前,就应当对所有在传送消息的信道进行监听。
	//但实际上不需要:
	//	不同于python-kronos那里面的信道只在(每一轮BFT中)handler打开时能够收到消息,
	//	sDumbo的channel写在实体里,消息分类等写在外面,与BFT本身没有什么耦合,
	//	在go routine没有开启的时候,消息就会躺在实体的Channels里,协程做的只是去“收货”和处理,不会错失消息。

	var point bool
	timer := 4

	//for e := uint32(1); e <= uint32(1); e++ { //e即epoch,时期
	for e := uint32(1); e <= uint32(epoch); e++ {
		ctx, cancel := context.WithCancel(context.Background())
		ctx_self, cancel_self := context.WithCancel(context.Background())
		point = false
		//时期的开始发送propose消息
		txs := <-itx_inputChannel //当inputChannel是[]byte时，每次接收一个字节切片(会阻塞)
		ProposeMessage := core.Encapsulation("Propose", utils.Uint32ToBytes(e), p.PID, &protobuf.Propose{
			Txs:     txs,
			Unknown: make([]byte, 0),
		})
		p.Intra_Broadcast(ProposeMessage)

		//监听别的BFT实例中的Leader发来的Propose消息,并进行点对点投票回复(VotePropose)
		go func(ctx context.Context) {
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-p.GetMessage("Propose", utils.Uint32ToBytes(e)):
					//payload := core.Decapsulation("Propose", m).(*protobuf.Message)
					//sig(payload,blablabla,,)
					VoteProposeMessage := core.Encapsulation("VotePropose", utils.Uint32ToBytes(e), p.PID, &protobuf.VotePropose{
						Unknown: make([]byte, 0),
					})
					p.Send(VoteProposeMessage, m.Sender)
				}
			}
		}(ctx)

		//监听别的BFT实例中的Leader发来的Commit消息,并进行点对点投票回复(VoteCommit)
		go func(ctx context.Context) {
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-p.GetMessage("Commit", utils.Uint32ToBytes(e)):
					//payload := core.Decapsulation("Commit", m).(*protobuf.Message)
					//sig(payload,blablabla,,)
					votecommitMessage := core.Encapsulation("VoteCommit", utils.Uint32ToBytes(e), p.PID, &protobuf.VoteCommit{
						Unknown: make([]byte, 0),
					})
					p.Send(votecommitMessage, m.Sender)
				}
			}
		}(ctx)

		//监听别的BFT实例中的Leader发来的Execute消息,到达一定数量(或等待过长时间)后关闭各个goroutine,结束本时期
		go func(ctx context.Context) {
			var l []int

			seen := make(map[int]bool)
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-p.GetMessage("Execute", utils.Uint32ToBytes(e)):
					if !seen[int(m.Sender)] {
						l = append(l, int(m.Sender))
						seen[int(m.Sender)] = true
					}
					if len(l) == int(p.N) {
						fmt.Println("Execute Finished, starting next epoch", e)
						point = true
						cancel()
						cancel_self()
					}
				}
			}
		}(ctx)

		//监听别的BFT(跨片)实例中的Leader发来的CrossPrepare消息,并进行点对点回复(CrossCommit)
		go func(ctx context.Context) {
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-p.GetMessage("CrossPrepare", utils.Uint32ToBytes(e)):
					//payload := core.Decapsulation("Commit", m).(*protobuf.Message)
					//sig(payload,blablabla,,)
					CrossCommitMessage := core.Encapsulation("CrossCommit", utils.Uint32ToBytes(e), p.PID, &protobuf.CrossCommit{
						Unknown: make([]byte, 0),
					})
					p.Send(CrossCommitMessage, m.Sender)
				}
			}
		}(ctx)

		//监听自己BFT实例中别的节点发来的VotePropose消息,到达门限后广播Commit消息(片内) 和CrossPrepare消息(片间)
		go func(ctx context.Context) {
			var l []int
			seen := make(map[int]bool)
		Loop:
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-p.GetMessage("VotePropose", utils.Uint32ToBytes(e)):
					if !seen[int(m.Sender)] {
						l = append(l, int(m.Sender))
						seen[int(m.Sender)] = true
					}
					if len(l) >= int(2*p.F+1) {
						break Loop
					}
				}
			}

			//aggregate([]payload,blablabla,,)
			commitMessage := core.Encapsulation("Commit", utils.Uint32ToBytes(e), p.PID, &protobuf.Commit{
				Aggsig: make([]byte, 0),
			})
			p.Intra_Broadcast(commitMessage)

			for i := 0; i < len(p.ShardList); i++ {
				CrossProposeMessage := core.Encapsulation("CrossPropose", utils.Uint32ToBytes(e), p.PID, &protobuf.CrossPropose{
					Txs:     txs,
					Unknown: make([]byte, 0),
				})
				p.Shard_Broadcast(CrossProposeMessage, uint32(p.ShardList[i]))
			}
		}(ctx_self)

		//监听自己BFT实例中别的节点发来的VoteCommit消息,到达门限后广播Execute消息(片内) 和CrossExecute消息(片间) 并执行交易(暂未想好怎么实现)
		go func(ctx context.Context) {
			var l []int
			seen := make(map[int]bool)
		Loop:
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-p.GetMessage("VoteCommit", utils.Uint32ToBytes(e)):
					if !seen[int(m.Sender)] {
						l = append(l, int(m.Sender))
						seen[int(m.Sender)] = true
					}
					if len(l) >= int(2*p.F+1) {
						break Loop
					}
				}
			}

			//aggregate([]payload,blablabla,,)
			executeMessage := core.Encapsulation("Execute", utils.Uint32ToBytes(e), p.PID, &protobuf.Execute{
				Unknown: make([]byte, 0),
			})
			p.Intra_Broadcast(executeMessage)

			for i := 0; i < len(p.ShardList); i++ {
				CrossExecuteMessage := core.Encapsulation("CrossExecute", utils.Uint32ToBytes(e), p.PID, &protobuf.CrossExecute{
					Unknown: make([]byte, 0),
				})
				p.Shard_Broadcast(CrossExecuteMessage, uint32(p.ShardList[i]))
			}
		}(ctx_self)

		t := time.Now()
		for {
			if time.Since(t) > time.Duration(timer)*time.Second {
				fmt.Println("Timeout reached, starting next epoch ", e)
				cancel()
				cancel_self()
				break
			} else {
				time.Sleep(100 * time.Microsecond)
			}
			if point {
				break
			}
		}
	}
}
