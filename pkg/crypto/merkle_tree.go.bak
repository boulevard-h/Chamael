package crypto

import (
	"bytes"
	"encoding/gob"
	"fmt"
	"strings"

	m "github.com/cbergoon/merkletree"
	"golang.org/x/crypto/sha3"
)

// 注册类型到 gob
func init() {
	gob.Register(&implContent{})
}

// implement of m.Content
type implContent struct {
	x []string
}

func buildImplContent(x []string) *implContent {
	return &implContent{x: x}
}

func (i *implContent) CalculateHash() ([]byte, error) {
	hash := sha3.Sum512([]byte(strings.Join(i.x, "")))
	return hash[:], nil
}

func (i *implContent) Equals(other m.Content) (bool, error) {
	hash1, _ := other.CalculateHash()
	hash2, _ := i.CalculateHash()
	if bytes.Equal(hash1, hash2) {
		return true, nil
	}
	return false, nil
}

//MerkleTree is a kind of vector commitment
type MerkleTree struct {
	mktree   *m.MerkleTree
	contents []m.Content
}

//NewMerkleTree generates a merkletree
func NewMerkleTree(data [][]string) (*MerkleTree, error) {
	contents := []m.Content{}
	for _, d := range data {
		c := buildImplContent(d)
		contents = append(contents, c)
	}
	mk, err := m.NewTreeWithHashStrategy(contents, sha3.New512)
	if err != nil {
		return nil, err
	}
	return &MerkleTree{
		mktree:   mk,
		contents: contents,
	}, nil
}

//GetMerkleTreeRoot returns a merkletree root
func (t *MerkleTree) GetMerkleTreeRoot() []byte {
	return t.mktree.MerkleRoot()
}

//GetMerkleTreeProof returns a vector commitment
func (t *MerkleTree) GetMerkleTreeProof(id int) ([][]byte, []int64) {
	path, indicator, _ := t.mktree.GetMerklePath(t.contents[id])
	return path, indicator
}

//VerifyMerkleTreeProof returns a vector commitment
func VerifyMerkleTreeProof(root []byte, proof [][]byte, indicator []int64, msg []string) bool {
	if len(proof) != len(indicator) {
		return false
	}
	itHash, _ := (&implContent{x: msg}).CalculateHash()
	for i, p := range proof {
		s := sha3.New512()
		if indicator[i] == 1 {
			s.Write(append(itHash, p...))
		} else if indicator[i] == 0 {
			s.Write(append(p, itHash...))
		} else {
			return false
		}
		itHash = s.Sum(nil)
	}
	return bytes.Equal(itHash, root)
}

// Marshal serializes the MerkleTree into a byte slice
func (mt *MerkleTree) Marshal() ([]byte, error) {
	var buf bytes.Buffer
	encoder := gob.NewEncoder(&buf)

	// 序列化 Mktree
	var mktreeData []byte
	if mt.mktree != nil {
		var err error
		mktreeData, err = marshalInternalMerkleTree(mt.mktree)
		if err != nil {
			return nil, err
		}
	}

	// 序列化 Contents
	var contentsData [][]byte
	for _, content := range mt.contents {
		if content != nil {
			if serializable, ok := content.(*implContent); ok {
				data, err := serializable.Serialize()
				if err != nil {
					return nil, err
				}
				contentsData = append(contentsData, data)
			} else {
				return nil, fmt.Errorf("unsupported content type: %T", content)
			}
		} else {
			contentsData = append(contentsData, nil)
		}
	}

	// 写入序列化数据
	err := encoder.Encode(mktreeData)
	if err != nil {
		return nil, err
	}
	err = encoder.Encode(contentsData)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes the byte slice into a MerkleTree
func (mt *MerkleTree) Unmarshal(data []byte) error {
	buf := bytes.NewBuffer(data)
	decoder := gob.NewDecoder(buf)

	// 反序列化 Mktree
	var mktreeData []byte
	err := decoder.Decode(&mktreeData)
	if err != nil {
		return err
	}
	if len(mktreeData) > 0 {
		mktree, err := unmarshalInternalMerkleTree(mktreeData)
		if err != nil {
			return err
		}
		mt.mktree = mktree
	}

	// 反序列化 Contents
	var contentsData [][]byte
	err = decoder.Decode(&contentsData)
	if err != nil {
		return err
	}

	// 恢复 Contents
	for _, contentData := range contentsData {
		if contentData == nil {
			mt.contents = append(mt.contents, nil)
			continue
		}
		content := &implContent{}
		err := content.Deserialize(contentData)
		if err != nil {
			return err
		}
		mt.contents = append(mt.contents, content)
	}

	return nil
}

func (c *implContent) Serialize() ([]byte, error) {
	var buf bytes.Buffer
	encoder := gob.NewEncoder(&buf)
	err := encoder.Encode(c.x)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (c *implContent) Deserialize(data []byte) error {
	buf := bytes.NewBuffer(data)
	decoder := gob.NewDecoder(buf)
	return decoder.Decode(&c.x)
}
func marshalInternalMerkleTree(mktree *m.MerkleTree) ([]byte, error) {
	if mktree == nil {
		return nil, nil
	}

	var buf bytes.Buffer
	encoder := gob.NewEncoder(&buf)

	// 转换 Root 为 LocalNode 并序列化
	root := convertToLocalNode(mktree.Root)
	if root != nil {
		rootData, err := root.MarshalBinary()
		if err != nil {
			return nil, err
		}
		err = encoder.Encode(rootData)
		if err != nil {
			return nil, err
		}
	} else {
		// 处理 Root 为 nil 的情况
		err := encoder.Encode([]byte{})
		if err != nil {
			return nil, err
		}
	}

	// 序列化 Leafs
	var leafDataList [][]byte
	for _, leaf := range mktree.Leafs {
		if leaf != nil {
			localLeaf := convertToLocalNode(leaf)
			leafData, err := localLeaf.MarshalBinary()
			if err != nil {
				return nil, err
			}
			leafDataList = append(leafDataList, leafData)
		} else {
			leafDataList = append(leafDataList, []byte{}) // 空叶子节点
		}
	}

	// Encode Leafs
	err := encoder.Encode(leafDataList)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}
func unmarshalInternalMerkleTree(data []byte) (*m.MerkleTree, error) {
	if len(data) == 0 {
		return nil, nil
	}

	var buf = bytes.NewBuffer(data)
	decoder := gob.NewDecoder(buf)

	mktree := &m.MerkleTree{}

	// 反序列化 Root
	var rootData []byte
	err := decoder.Decode(&rootData)
	if err != nil {
		return nil, err
	}
	if len(rootData) > 0 {
		root := &LocalNode{}
		err := root.UnmarshalBinary(rootData)
		if err != nil {
			return nil, err
		}
		mktree.Root = convertFromLocalNode(root)
	}

	// 反序列化 Leafs
	var leafDataList [][]byte
	err = decoder.Decode(&leafDataList)
	if err != nil {
		return nil, err
	}

	for _, leafData := range leafDataList {
		if len(leafData) > 0 {
			leafNode := &LocalNode{}
			err := leafNode.UnmarshalBinary(leafData)
			if err != nil {
				return nil, err
			}
			mktree.Leafs = append(mktree.Leafs, convertFromLocalNode(leafNode))
		} else {
			mktree.Leafs = append(mktree.Leafs, nil) // 空叶子节点
		}
	}

	// 恢复 Parent 指针
	setParentPointers(mktree.Root, nil)

	return mktree, nil
}

type LocalNode m.Node

func (n *LocalNode) MarshalBinary() ([]byte, error) {
	var buf bytes.Buffer
	encoder := gob.NewEncoder(&buf)

	// 序列化 Hash
	err := encoder.Encode(n.Hash)
	if err != nil {
		return nil, err
	}

	// 序列化 Left 节点
	if n.Left != nil {
		leftLocalNode := convertToLocalNode(n.Left) // 转换为 LocalNode
		leftData, err := leftLocalNode.MarshalBinary()
		if err != nil {
			return nil, err
		}
		err = encoder.Encode(leftData)
		if err != nil {
			return nil, err
		}
	} else {
		err = encoder.Encode([]byte{}) // 空节点标记
		if err != nil {
			return nil, err
		}
	}

	// 序列化 Right 节点
	if n.Right != nil {
		rightLocalNode := convertToLocalNode(n.Right) // 转换为 LocalNode
		rightData, err := rightLocalNode.MarshalBinary()
		if err != nil {
			return nil, err
		}
		err = encoder.Encode(rightData)
		if err != nil {
			return nil, err
		}
	} else {
		err = encoder.Encode([]byte{}) // 空节点标记
		if err != nil {
			return nil, err
		}
	}

	return buf.Bytes(), nil
}
func (n *LocalNode) UnmarshalBinary(data []byte) error {
	buf := bytes.NewBuffer(data)
	decoder := gob.NewDecoder(buf)

	// 反序列化 Hash
	err := decoder.Decode(&n.Hash)
	if err != nil {
		return err
	}

	// 反序列化 Left 节点
	var leftData []byte
	err = decoder.Decode(&leftData)
	if err != nil {
		return err
	}
	if len(leftData) > 0 {
		leftNode := &LocalNode{}
		err = leftNode.UnmarshalBinary(leftData)
		if err != nil {
			return err
		}
		n.Left = convertFromLocalNode(leftNode) // 转换为原始 Node
	}

	// 反序列化 Right 节点
	var rightData []byte
	err = decoder.Decode(&rightData)
	if err != nil {
		return err
	}
	if len(rightData) > 0 {
		rightNode := &LocalNode{}
		err = rightNode.UnmarshalBinary(rightData)
		if err != nil {
			return err
		}
		n.Right = convertFromLocalNode(rightNode) // 转换为原始 Node
	}

	return nil
}
func convertToLocalNode(node *m.Node) *LocalNode {
	if node == nil {
		return nil
	}
	return (*LocalNode)(node)
}
func convertFromLocalNode(node *LocalNode) *m.Node {
	if node == nil {
		return nil
	}
	return (*m.Node)(node)
}
func setParentPointers(node *m.Node, parent *m.Node) {
	if node == nil {
		return
	}
	node.Parent = parent
	setParentPointers(node.Left, node)
	setParentPointers(node.Right, node)
}
